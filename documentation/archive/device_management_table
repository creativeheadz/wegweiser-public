---

# **Device Management Table Rendering and Column Toggling**

## **Overview**
This document provides a detailed explanation of the JavaScript, HTML, and DataTables setup used for rendering the **Device Management** table, handling dynamic column toggling, saving user preferences, and other related functionalities. This solution allows users to show/hide columns, persist those preferences, and interact with the table efficiently.

## **Key Components**
1. **HTML Template Structure**
   - The core HTML structure for rendering the table.
2. **JavaScript for Column Toggling**
   - The script responsible for handling column visibility using DataTables' API.
3. **Saving and Loading Column Preferences**
   - Persisting user preferences for table configuration.
4. **Other Features**
   - Handling health scores, tags, and real-time AI chat functionality with devices.

---

## **1. HTML Template Structure**

The primary table is rendered in the `list.html` file, which is included in the `index.html` template. The structure uses the Jinja templating engine (part of Flask) to dynamically populate table headers and rows based on the available data.

### **list.html**
- **Filepath**: `app/templates/devices/list.html`

This file contains the core table rendering logic:

```html
<table id="example2" class="table align-middle text-nowrap">
    <thead class="table-light">
        <tr>
            {% for column in columns %}
            <th class="col-{{ column.name }}">{{ column.label }}</th>
            {% endfor %}
            <th>Action</th>
        </tr>
    </thead>
    <tbody>
        {% for device in devices %}
        <tr>
            {% for column in columns %}
            <td class="col-{{ column.name }}">
                <!-- Column specific logic -->
                {% if column.name == 'devicename' %}
                    <!-- Render device name and icon -->
                {% elif column.name == 'health_score' %}
                    <!-- Render health score with progress bar -->
                {% elif column.name == 'tags' %}
                    <!-- Render tags modal button -->
                {% else %}
                    <!-- Default: render the data -->
                {% endif %}
            </td>
            {% endfor %}
            <td>
                <!-- Action buttons for each device -->
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>
```

### **index.html**
- **Filepath**: `app/templates/devices/index.html`

This file wraps the table inside a broader layout and includes the **column toggling** interface:

```html
<div class="btn-group">
    <button type="button" class="btn btn-primary">Settings</button>
    <button type="button" class="btn btn-primary split-bg-primary dropdown-toggle dropdown-toggle-split" data-bs-toggle="dropdown">
        <span class="visually-hidden">Toggle Dropdown</span>
    </button>
    <div class="dropdown-menu dropdown-menu-right dropdown-menu-lg-end">
        <h6 class="dropdown-header">Toggle Columns</h6>
        {% for column in columns %}
        <div class="dropdown-item">
            <div class="form-check">
                <input class="form-check-input column-toggle" type="checkbox" value="{{ column.name }}" id="col-{{ column.name }}" {% if column.visible %}checked{% endif %}>
                <label class="form-check-label" for="col-{{ column.name }}">{{ column.label }}</label>
            </div>
        </div>
        {% endfor %}
        <div class="dropdown-divider"></div>
        <a class="dropdown-item" href="javascript:;" id="save-column-preferences">Save Preferences</a>
    </div>
</div>
```

### **Explanation**
1. **Column Toggling UI**: This is the user interface (UI) that allows users to toggle visibility of table columns. It uses checkboxes where each checkbox corresponds to a column in the table.
2. **Table Structure**: The table dynamically generates both the headers (`<th>`) and data cells (`<td>`) based on the `columns` and `devices` objects passed to the template.
3. **Column-Specific Logic**: Certain columns (like `devicename`, `health_score`, and `tags`) have custom rendering logic for formatting the output.

---

## **2. JavaScript for Column Toggling and DataTables Integration**

The `device_management.js` file handles dynamic behavior for the table, including:
- Initializing the table using **DataTables**.
- Toggling columns based on user interaction.
- Saving column visibility preferences to `localStorage`.
- Managing additional functionalities such as AI chat and health scores.

### **device_management.js**
- **Filepath**: `static/js/device_management.js`

#### **Table Initialization**
```javascript
function initializeTables() {
    if ($.fn.DataTable.isDataTable('#example2')) {
        $('#example2').DataTable().destroy();  // Destroy existing table instance
    }
    var table = $('#example2').DataTable({
        lengthChange: false,
        buttons: ['copy', 'excel', 'pdf', 'print']
    });
    table.buttons().container().appendTo('#example2_wrapper .col-md-6:eq(0)');
}
```
- **Explanation**: This function initializes the DataTables plugin, which enhances the HTML table with features like pagination, search, export buttons, etc.

#### **Column Toggling with DataTables**
```javascript
document.querySelectorAll('.column-toggle').forEach(function(checkbox, index) {
    let columnIndex = index;  // Use the checkbox index to match the table column
    let isVisible = savedPreferences[checkbox.value] ?? checkbox.checked;

    checkbox.checked = isVisible;
    table.column(columnIndex).visible(isVisible);

    checkbox.addEventListener('change', function() {
        table.column(columnIndex).visible(this.checked);
    });
});
```
- **Explanation**:
  - The `column-toggle` checkboxes are mapped to table columns by their index.
  - When a checkbox is toggled, the corresponding column’s visibility is managed by DataTables' `.column().visible()` API.

---

## **3. Saving and Loading Column Preferences**

The user’s column visibility preferences are saved in **localStorage**. This ensures that preferences persist across page reloads or sessions on the same browser.

#### **Saving Preferences**
```javascript
document.getElementById('save-column-preferences')?.addEventListener('click', function() {
    let preferences = {};
    document.querySelectorAll('.column-toggle').forEach(function(checkbox) {
        preferences[checkbox.value] = checkbox.checked;
    });
    localStorage.setItem('columnPreferences', JSON.stringify(preferences));
    showNotification('success', 'Preferences saved!');
});
```
- **Explanation**: When the user clicks "Save Preferences", the current state of all column checkboxes is saved to `localStorage`. Each column’s name (e.g., `devicename`, `health_score`) is used as the key, and its checked state (visible or hidden) is saved as the value.

#### **Restoring Preferences**
```javascript
let savedPreferences = JSON.parse(localStorage.getItem('columnPreferences')) || {};
document.querySelectorAll('.column-toggle').forEach(function(checkbox, index) {
    let columnIndex = index;
    let isVisible = savedPreferences[checkbox.value] ?? checkbox.checked;
    checkbox.checked = isVisible;
    table.column(columnIndex).visible(isVisible);
});
```
- **Explanation**: When the page loads, the saved preferences from `localStorage` are applied, making sure that the table’s column visibility reflects the user’s previous choices.

---

## **4. Additional Features**

### **AI Chat Integration**
The JavaScript file also handles AI chat interactions with each device, allowing users to send messages and receive responses from the AI:

```javascript
function initializeAIChat(deviceUuid) {
    const chatForm = document.getElementById(`chatForm-${deviceUuid}`);
    const chatInput = document.getElementById(`chatInput-${deviceUuid}`);
    const chatContainer = document.getElementById(`chatContainer-${deviceUuid}`);

    if (chatForm && chatInput && chatContainer) {
        chatForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (message) {
                addChatMessage(chatContainer, 'You', message);
                chatInput.value = '';

                fetch(`/ai/device/${deviceUuid}/chat`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ message: message }),
                })
                .then(response => response.json())
                .then(data => {
                    addChatMessage(chatContainer, 'AI', data.response);
                });
            }
        });
    }
}
```
- **Explanation**: The function initializes an AI chat for each device. Users can send a message, and the AI will respond, with messages appended to the chat container.

### **Health Score Updates**
```javascript
function updateHealthScore(deviceUuid) {
    fetch(`/ai/device/${deviceUuid}/health_score`)
        .then(response => response.json())
        .then(data => {
            const scoreElement = document.getElementById(`health-score-${deviceUuid}`);
            if (scoreElement) {
                scoreElement.textContent = `${data.health_score}%`;
                scoreElement.className = `badge bg-${data.health_score >= 70 ? 'success' : data.health_score >= 40 ? 'warning' : 'danger'}`;


            }
        });
}
```
- **Explanation**: This function fetches the updated health score of a device and dynamically updates the score displayed in the table, along with a color-coded badge indicating the status.

---

## **Conclusion**

This setup combines HTML, JavaScript, and the DataTables API to create a fully interactive device management table. It supports dynamic column toggling, persisting user preferences, real-time AI interaction with devices, and more. This system provides a scalable and user-friendly interface for managing and monitoring devices in an administrative environment.

By following the above implementation, you can ensure the table behaves consistently and dynamically in response to user interactions, enhancing both usability and functionality.

--- 
